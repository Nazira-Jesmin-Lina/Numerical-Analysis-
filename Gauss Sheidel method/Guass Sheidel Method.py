# -*- coding: utf-8 -*-
"""Lab5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1phoen1jwJobpY19q13EWiQvDzxxuPyJW
"""

import numpy as np
import matplotlib.pyplot as plt
import time

def jacobi_without_matrix():
    x = np.zeros(n_eq)
    num_iterations = 20

    iteration_list = []
    appx_error_list = []
    time_list = []
    start_time = time.time()
    for iteration in range(num_iterations):
        new_x = np.zeros(n_eq)
        for i in range(n_eq):
            new_x[i] = (b[i] - np.dot(A[i, :i], new_x[:i]) - np.dot(A[i, i+1:], x[i+1:])) / A[i, i]

        errors = np.abs(new_x - x)
        x = new_x.copy()

        total_error = np.sum(errors)
        appx_error_list.append(total_error)
        iteration_list.append(iteration + 1)
        elapsed_time = time.time() - start_time
        time_list.append(elapsed_time)

        if total_error <= 10 ** -6:
            break


    return iteration_list, time_list,appx_error_list,iteration_list



def GaussSheidel_without_matrix():
    x = np.zeros(n_eq)
    num_iterations = 20

    iteration_list = []
    appx_error_list = []
    time_list = []
    start_time = time.time()
    print( "                    Gauss Sheidel without matrix                  ")
    for iteration in range(num_iterations):
        new_x = np.zeros(n_eq)
        for i in range(n_eq):
            new_x[i] = (b[i] - np.dot(A[i, :i], new_x[:i]) - np.dot(A[i, i+1:], x[i+1:])) / A[i, i]
            errors = np.abs(new_x - x)
            x = new_x.copy()


        total_error = np.sum(errors)
        appx_error_list.append(total_error)
        iteration_list.append(iteration + 1)
        elapsed_time = time.time() - start_time
        time_list.append(elapsed_time)

        if total_error <= 10 ** -3:
            break

        print(f"Iteration {iteration + 1}: x = {x[0]}  y = {x[1]}  z = {x[2]}  total error = {total_error}")

    plt.plot(iteration_list, appx_error_list, marker='o')
    plt.xlabel('Iteration')
    plt.ylabel('Approximation Error')
    plt.title('Approximation Error vs. Iteration')
    plt.grid()
    plt.show()

    plt.plot(iteration_list, time_list, marker='o')
    plt.xlabel('Iteration')
    plt.ylabel('Time')
    plt.title('Time Error vs. Iteration')
    plt.grid()
    plt.show()

    return iteration_list, time_list,appx_error_list,iteration_list

def GaussSheidel_with_matrix(A, b, x0, tol=1e-6, max_iter=100):
    n_eq = len(b)
    x = x0.copy()
    error_list = []
    runtime_list = []
    elapsed_time = 0
    D = np.diag(np.diag(A))
    L = -np.tril(A, k=-1)
    U = -np.triu(A, k=1)
    iteration_list=[]
    print( "                    Gauss Sheidel with matrix                  ")

    for _ in range(max_iter):
        start_time = time.time()
        x_new = np.linalg.inv(D).dot(b + L.dot(x) + U.dot(x))
        error = np.linalg.norm(x_new - x, ord=np.inf)
        elapsed_time += time.time() - start_time
        error_list.append(error)
        runtime_list.append(elapsed_time)
        iteration_list.append(_ + 1)
        if error <= tol:
            break
        print("Value of x(k) for each iteration: ", x_new)
        x = x_new

    plt.plot(iteration_list, error_list, marker='o')
    plt.xlabel('Iteration')
    plt.ylabel('Approximation Error')
    plt.title('Approximation Error vs. Iteration with matrix')
    plt.grid()
    plt.show()

    plt.plot(iteration_list, runtime_list, marker='o')
    plt.xlabel('Iteration')
    plt.ylabel('Runtime (seconds)')
    plt.title('Runtime vs. Iteration with matrix')
    plt.legend()
    plt.grid()
    plt.show()
    return x, error_list, runtime_list



def jacobi_with_matrix(A, b, x0, tol=1e-6, max_iter=100):
    n_eq = len(b)
    x = x0.copy()
    error_list = []
    runtime_list = []
    elapsed_time = 0
    D = np.diag(np.diag(A))
    L = -np.tril(A, k=-1)
    U = -np.triu(A, k=1)
    iteration_list=[]
    for _ in range(max_iter):
        start_time = time.time()
        x_new = np.linalg.inv(D).dot(b + L.dot(x) + U.dot(x))
        error = np.linalg.norm(x_new - x, ord=np.inf)
        elapsed_time += time.time() - start_time
        error_list.append(error)
        runtime_list.append(elapsed_time)
        iteration_list.append(_ + 1)
        if error <= tol:
            break
        x = x_new

    return x, error_list, runtime_list



n_eq = int(input(" the number of equations "))

A = np.zeros((n_eq, n_eq))
b = np.zeros(n_eq)

print("the coefficients")
for i in range(n_eq):
    row = list(map(float, input().split()))
    A[i, :] = row

print("constants:")
for i in range(n_eq):
    b[i] = float(input())

xx, yy,err_j,itt_j = jacobi_without_matrix()
xs,ys,err_G,itt_G=GaussSheidel_without_matrix()

x0 = np.zeros(n_eq)
x1=np.zeros(n_eq)
tolerance = 1e-6
max_iterations = 100

solution, errors, runtimes = jacobi_with_matrix(A, b, x0, tol=tolerance, max_iter=max_iterations)
solution_s, errors_s, runtimes_s = GaussSheidel_with_matrix(A, b, x1, tol=tolerance, max_iter=max_iterations)

iteration_list = list(range(1, len(runtimes) + 1))



plt.plot(iteration_list, runtimes_s, marker='o', label='With Matrix')
plt.plot(xs, ys, marker='o', label='Without Matrix')
plt.xlabel('Iteration')
plt.ylabel('Runtime (seconds)')
plt.title('Runtime Comparison For Gauss sheidel Method')
plt.legend()
plt.grid()
plt.show()


plt.plot(itt_j, err_j, marker='o', label='Jacobi')
plt.plot(itt_G,err_G , marker='o', label='Gauss Sheidel')
plt.xlabel('Iteration')
plt.ylabel('Runtime (seconds)')
plt.title('Error comparision with jacobi and Gauss sheidel Method')
plt.legend()
plt.grid()
plt.show()